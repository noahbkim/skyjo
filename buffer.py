import numpy as np

import selfplay
import skynet


class ReplayBuffer:
    """A replay buffer to hold the experience generated by the played games.

        Each element in the buffer is a list of training data points generated
    from a single game. Once the buffer is full, the oldest game is discarded.

        Sampling from the buffer returns a random batch of training data points
    from across all games.

    This is NOT thread safe.
    """

    def __init__(self, max_games: int):
        self.max_games = max_games
        self.game_data_lengths = []
        self.spatial_input_buffer = []
        self.non_spatial_input_buffer = []
        self.policy_target_buffer = []
        self.outcome_target_buffer = []
        self.points_target_buffer = []
        self.games_count = 0

    def __len__(self):
        return len(self.spatial_input_buffer)

    def _remove_oldest_game(self):
        self.spatial_input_buffer = self.spatial_input_buffer[
            self.game_data_lengths[0] :
        ]
        self.non_spatial_input_buffer = self.non_spatial_input_buffer[
            self.game_data_lengths[0] :
        ]
        self.policy_target_buffer = self.policy_target_buffer[
            self.game_data_lengths[0] :
        ]
        self.outcome_target_buffer = self.outcome_target_buffer[
            self.game_data_lengths[0] :
        ]
        self.points_target_buffer = self.points_target_buffer[
            self.game_data_lengths[0] :
        ]
        self.game_data_lengths = self.game_data_lengths[1:]
        self.games_count -= 1

    def add_game_data_with_symmetry(self, game_data: list[tuple]):
        """Adds a game's worth of training data to the buffer."""
        # Buffer is full
        if self.games_count == self.max_games:
            self._remove_oldest_game()
        game_data_length = 0
        for game_state, policy_target, outcome_target, points_target in game_data:
            for (
                symmetric_game_state,
                symmetric_policy_target,
            ) in selfplay.get_skyjo_symmetries(game_state, policy_target):
                self.spatial_input_buffer.append(
                    skynet.get_spatial_state_numpy(symmetric_game_state)
                )
                self.non_spatial_input_buffer.append(
                    skynet.get_non_spatial_state_numpy(symmetric_game_state)
                )
                self.policy_target_buffer.append(symmetric_policy_target)
                self.outcome_target_buffer.append(outcome_target)
                self.points_target_buffer.append(points_target)
                game_data_length += 1
            self.game_data_lengths.append(game_data_length)

        self.games_count += 1

    def sample_element(self) -> skynet.TrainingDataPoint:
        assert (
            len(self.spatial_input_buffer)
            == len(self.non_spatial_input_buffer)
            == len(self.policy_target_buffer)
            == len(self.outcome_target_buffer)
            == len(self.points_target_buffer)
        ), "All buffers must be the same length"
        assert len(self.spatial_input_buffer) > 0, "Buffer is empty"
        # Select a random index first
        index = np.random.randint(len(self.spatial_input_buffer))
        return (
            self.spatial_input_buffer[index],
            self.non_spatial_input_buffer[index],
            self.policy_target_buffer[index],
            self.outcome_target_buffer[index],
            self.points_target_buffer[index],
        )

    def sample_batch(self, batch_size: int) -> skynet.TrainingBatch:
        assert (
            len(self.spatial_input_buffer)
            == len(self.non_spatial_input_buffer)
            == len(self.policy_target_buffer)
            == len(self.outcome_target_buffer)
            == len(self.points_target_buffer)
        ), "All buffers must be the same length"
        assert len(self.spatial_input_buffer) > 0, "Buffer is empty"
        assert batch_size <= len(self.spatial_input_buffer), (
            f"Batch size {batch_size} cannot be larger than buffer size {len(self.spatial_input_buffer)} when sampling without replacement."
        )
        indices = np.random.choice(
            len(self.spatial_input_buffer), size=batch_size, replace=False
        )
        # Retrieve elements using the sampled indices
        batch = (
            np.array([self.spatial_input_buffer[i] for i in indices]),
            np.array([self.non_spatial_input_buffer[i] for i in indices]),
            np.array([self.policy_target_buffer[i] for i in indices]),
            np.array([self.outcome_target_buffer[i] for i in indices]),
            np.array([self.points_target_buffer[i] for i in indices]),
        )
        return batch
